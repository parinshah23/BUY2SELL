generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  isAdmin   Boolean  @default(false)
  avatar    String?  // URL to avatar image
  bio       String?  // User biography
  googleId  String?  @unique // Google OAuth ID

  // Relationships
  products     Product[]
  orders       Order[]       @relation("BuyerOrders")
  sales        Order[]       @relation("SellerOrders")
  wallet       Wallet?
  chatsAsBuyer Chat[]    @relation("BuyerChats")
  chatsAsSeller Chat[]   @relation("SellerChats")
  messages     Message[]
  reviews      Review[]
  
  // Blocking & Reporting
  blocksInitiated Block[] @relation("BlocksInitiated")
  blocksReceived  Block[] @relation("BlocksReceived")
  reportsInitiated Report[] @relation("ReportsInitiated")
  reportsReceived  Report[] @relation("ReportsReceived")

  // KYC & Address
  isVerified Boolean @default(false)
  kycStatus  KYCStatus @default(NOT_SUBMITTED)
  kycDocs    String[]
  addresses  Address[]
}

model Address {
  id        Int      @id @default(autoincrement())
  name      String   // Recipient Name
  street    String
  city      String
  state     String
  zip       String
  country   String
  isDefault Boolean  @default(false)
  
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
}

model Product {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  price       Float
  stock       Int      @default(1) // Inventory Count
  category    String
  images      String[] // Changed from single image to array
  location    String?  // New: City, State
  latitude    Float?   // New: For map
  longitude   Float?   // New: For map
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  status      ProductStatus @default(AVAILABLE)

  user   User @relation(fields: [userId], references: [id])
  userId Int

  // Relationship with Order
  orders Order[]
  chats Chat[]
  reviews Review[]
}

model Order {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status    OrderStatus @default(PENDING)
  totalAmount     Float // Total paid by buyer
  platformFee     Float // 4% fee
  sellerEarnings  Float // Amount to be transferred to seller

  stripeSessionId String? @unique
  paymentIntentId String?

  product   Product  @relation(fields: [productId], references: [id])
  productId Int      // Removed @unique to allow product history if needed, but for now logic enforces single active order

  buyer     User     @relation("BuyerOrders", fields: [buyerId], references: [id])
  buyerId   Int

  seller    User     @relation("SellerOrders", fields: [sellerId], references: [id])
  sellerId  Int
}

model Wallet {
  id        Int      @id @default(autoincrement())
  balance   Float    @default(0.0) // Available for withdrawal
  pending   Float    @default(0.0) // Held in escrow

  user      User     @relation(fields: [userId], references: [id])
  userId    Int      @unique

  transactions WalletTransaction[]
}

model WalletTransaction {
  id        Int      @id @default(autoincrement())
  amount    Float
  type      TransactionType
  description String
  createdAt DateTime @default(now())

  wallet    Wallet   @relation(fields: [walletId], references: [id])
  walletId  Int
}

model Chat {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product   Product @relation(fields: [productId], references: [id])
  productId Int

  buyer     User @relation("BuyerChats", fields: [buyerId], references: [id])
  buyerId   Int

  seller    User @relation("SellerChats", fields: [sellerId], references: [id])
  sellerId  Int

  messages  Message[]

  @@unique([productId, buyerId, sellerId]) // One chat per product between specific buyer/seller
}

model Message {
  id        Int      @id @default(autoincrement())
  content   String?  // Made optional for image-only messages
  image     String?  // New: Image attachment
  createdAt DateTime @default(now())
  read      Boolean  @default(false)

  chat   Chat @relation(fields: [chatId], references: [id])
  chatId Int

  sender   User @relation(fields: [senderId], references: [id])
  senderId Int
}

model Review {
  id        Int      @id @default(autoincrement())
  rating    Int      // 1-5 stars
  comment   String?
  createdAt DateTime @default(now())

  product   Product @relation(fields: [productId], references: [id])
  productId Int

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([productId, userId]) // One review per product per user
}

model Block {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  blocker   User @relation("BlocksInitiated", fields: [blockerId], references: [id])
  blockerId Int

  blocked   User @relation("BlocksReceived", fields: [blockedId], references: [id])
  blockedId Int

  @@unique([blockerId, blockedId])
}

model Report {
  id        Int      @id @default(autoincrement())
  reason    String
  createdAt DateTime @default(now())
  status    ReportStatus @default(PENDING)

  reporter   User @relation("ReportsInitiated", fields: [reporterId], references: [id])
  reporterId Int

  reported   User @relation("ReportsReceived", fields: [reportedId], references: [id])
  reportedId Int
}

enum ProductStatus {
  AVAILABLE
  SOLD
}

enum OrderStatus {
  PENDING
  PAID
  SHIPPED
  DELIVERED
  COMPLETED
  DISPUTED
  CANCELLED
  REFUNDED
}

enum ReportStatus {
  PENDING
  RESOLVED
  DISMISSED
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  SALE
  REFUND
}

enum KYCStatus {
  NOT_SUBMITTED
  PENDING
  VERIFIED
  REJECTED
}
